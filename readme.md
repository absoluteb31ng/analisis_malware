# PROGRAMA PARA EL ANALISIS ESTATICO DE MALWARE

## Este proyecto es un analizador de malware estático que examina archivos ejecutables de Windows (PE) y Linux (ELF) para extraer información relevante, como hashes, cadenas legibles, funciones importadas, y desensamblado del código a ensamblador. Utiliza Python junto con herramientas de análisis como pefile, objdump y readelf.

## Requisitos

- **Python 3**
- Librerías de Python:
  - `pefile`: Puedes instalarla ejecutando:
    ```
    pip install pefile
    ```
- Herramientas de Linux:
  - `binutils`: proporciona `objdump` y `readelf`.
    - Instalación:
      ```
      sudo apt-get install binutils
      ```

## Cómo Usar

1. Ejecuta el script proporcionando la ruta del archivo que deseas analizar:
   ```bash
   python estatic.py
   
+ Descripción del Código
  - 1. Cálculo de Hashes
    - La función **calcular_hashes** calcula los hashes MD5, SHA-1 y SHA-256 del archivo que se está analizando.
```
def calcular_hashes(ruta_archivo):
    """Calcula los hashes MD5, SHA-1 y SHA-256 de un archivo dado."""
    hashes = {'MD5': hashlib.md5(), 'SHA-1': hashlib.sha1(), 'SHA-256': hashlib.sha256()}
    with open(ruta_archivo, 'rb') as f:
        while chunk := f.read(8192):
            for hash in hashes.values():
                hash.update(chunk)
    return {nombre: hash.hexdigest() for nombre, hash in hashes.items()}
```
  - Propósito: Calcular los hashes ayuda a identificar el archivo y compararlo con bases de datos de malware.


    ## 2. Extracción de Cadenas de Texto
      La función **extraer_cadenas** extrae cadenas legibles de un archivo binario que tienen un mínimo de 4 caracteres.
    ```
    def extraer_cadenas(ruta_archivo, min_len=4):
    """Extrae cadenas legibles de un archivo binario."""
    with open(ruta_archivo, 'rb') as f:
        contenido = f.read()
    resultado = []
    cadena = ""
    for byte in contenido:
        if 32 <= byte < 127:
            cadena += chr(byte)
            continue
        if len(cadena) >= min_len:
            resultado.append(cadena)
        cadena = ""
    return resultado
    ```
    - Propósito: Las cadenas de texto pueden revelar información sobre el comportamiento del malware, como nombres de funciones, URLs o mensajes internos.

## 3. Análisis de Funciones Importadas (PE)
La función **analizar_importaciones** analiza las funciones importadas por un archivo PE.
```
def analizar_importaciones(pe):
    """Lista las funciones importadas por un archivo PE."""
    if not hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
        return []
    importaciones = []
    for entrada in pe.DIRECTORY_ENTRY_IMPORT:
        for funcion in entrada.imports:
            importaciones.append((entrada.dll.decode(), funcion.name.decode() if funcion.name else ''))
    return importaciones
```
  - Propósito: Las funciones importadas permiten entender qué bibliotecas externas utiliza el archivo, lo que da pistas sobre su comportamiento.

## 4. Desensamblado del Archivo a Ensamblador
La función **desensamblar_archivo** utiliza objdump para desensamblar el archivo y mostrar su código ensamblador.
```
def desensamblar_archivo(ruta_archivo):
    """Desensambla un archivo utilizando objdump."""
    try:
        resultado = subprocess.run(['objdump', '-d', ruta_archivo], capture_output=True, text=True, check=True)
        return resultado.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print(f"Error al desensamblar el archivo: {e}")
        return []
```
  - Propósito: El código ensamblador muestra instrucciones de bajo nivel que pueden ayudar a entender el comportamiento del malware.

## 5. Análisis del Archivo PE
La función **analizar_archivo_pe** utiliza **pefile** para extraer las funciones importadas del archivo PE.
```
def analizar_archivo_pe(ruta_archivo):
    """Analiza un archivo PE y extrae información relevante."""
    try:
        pe = pefile.PE(ruta_archivo)
        print("\nFunciones importadas:")
        importaciones = analizar_importaciones(pe)
        for dll, funcion in importaciones:
            print(f"{dll}: {funcion}")
    except pefile.PEFormatError:
        print("El archivo no es un ejecutable PE válido.")
```
  - Propósito: Extrae y muestra información específica de archivos ejecutables de Windows.

## 6. Análisis del Archivo ELF
La función **analizar_archivo_elf** utiliza **readelf** para analizar archivos ELF.
```
def analizar_archivo_elf(ruta_archivo):
    """Analiza un archivo ELF y extrae información relevante."""
    try:
        resultado = subprocess.run(['readelf', '-a', ruta_archivo], capture_output=True, text=True, check=True)
        return resultado.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print(f"Error al analizar el archivo ELF: {e}")
        return []
```
  - Propósito: Extrae información detallada sobre archivos ejecutables de Linux.

## 7. Función Principal: Análisis del Archivo
La función **analizar_archivo** controla el flujo del programa y determina qué tipo de archivo se está analizando (PE o ELF).
```
def analizar_archivo(ruta_archivo):
    """Analiza un archivo ejecutable y extrae información relevante según el tipo de archivo."""
    if not os.path.exists(ruta_archivo):
        print(f"Archivo no encontrado: {ruta_archivo}")
        return

    print(f"Analizando archivo: {ruta_archivo}")

    # Calcular hashes del archivo
    hashes = calcular_hashes(ruta_archivo)
    print("\nHashes del archivo:")
    for nombre, hash in hashes.items():
        print(f"{nombre}: {hash}")

    # Extraer cadenas de texto
    print("\nCadenas encontradas en el archivo:")
    cadenas = extraer_cadenas(ruta_archivo)
    for cadena in cadenas[:10]:  # Muestra las primeras 10 cadenas encontradas
        print(cadena)

    # Determinar el tipo de archivo
    tipo_mime, _ = mimetypes.guess_type(ruta_archivo)
    es_pe = tipo_mime == "application/x-dosexec"
    es_elf = not es_pe and tipo_mime == "application/x-executable"

    if es_pe or ruta_archivo.lower().endswith(('.exe', '.dll')):
        print("\nAnalizando archivo PE...")
        analizar_archivo_pe(ruta_archivo)
    elif es_elf or os.access(ruta_archivo, os.X_OK):
        print("\nAnalizando archivo ELF...")
        elf_info = analizar_archivo_elf(ruta_archivo)
        for line in elf_info[:20]:  # Mostrar las primeras 20 líneas de la salida de readelf
            print(line)
    else:
        print("Tipo de archivo no soportado para análisis.")

    # Desensamblar el archivo a ASM
    print("\nDesensamblando el archivo a ASM...")
    asm_lines = desensamblar_archivo(ruta_archivo)
    for line in asm_lines[:20]:  # Muestra las primeras 20 líneas del ensamblador
        print(line)
```
  - Propósito: Coordina el análisis del archivo, calcula los hashes, extrae cadenas, analiza importaciones y desensambla el archivo según sea PE o ELF.

### OBSERVACIONES
- Este analizador de malware estático es una herramienta útil para entender el comportamiento de archivos ejecutables, proporcionando una visión general de cómo 
interactúan con el sistema. Es útil para la investigación de malware, análisis forense y estudios de seguridad informática.

+ Gracias por leer, si tienen alguna sugerencia o critica pueden hacermelo saber :D
